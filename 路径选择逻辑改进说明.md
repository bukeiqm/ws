# 路径选择逻辑改进说明

## 改进目标

增加一个变量存储行人选定的下一个目标点的ID，当每次路径选择后的ID与此ID不同时，不更新这个变量；行人以这个ID为标准进行移动，只在移动到位后更新这个ID。

## 实现方案

### 1. 新增字段

在 `AgentData` 类中新增 `committed_target_area_id` 字段：

```python
committed_target_area_id: int = -1  # 已承诺的下一个目标区域ID（实际移动目标）
```

**字段说明：**
- `next_target_area_id`：路径规划建议的下一个目标区域ID（可能频繁变化）
- `committed_target_area_id`：已承诺的下一个目标区域ID（实际移动目标，只在到达后更新）

### 2. 核心逻辑

#### 2.1 路径选择时的处理

在 `update_path()` 和 `update_state()` 中，当进行路径选择时：

```python
chosen_id = self.choose_path(...)
if chosen_id is not None:
    # 只有当选择的ID与已承诺的ID相同时，才更新承诺的ID
    if chosen_id == agent.committed_target_area_id:
        agent.next_target_area_id = chosen_id
        # 更新路径索引等
    else:
        # 选择的ID与承诺的ID不同，只更新next_target_area_id（用于规划），不更新承诺的ID
        agent.next_target_area_id = chosen_id
```

**逻辑说明：**
- 如果新选择的ID与当前承诺的ID相同，说明路径规划确认了当前目标，可以更新相关状态
- 如果新选择的ID与当前承诺的ID不同，说明路径规划建议了新的目标，但不立即改变承诺的目标，只更新建议值

#### 2.2 目标点确定

在 `update_state()` 中，使用 `committed_target_area_id` 来确定实际移动目标：

```python
# 确定目标点（用于计算加速度）
# 使用committed_target_area_id来确定目标点，而不是next_target_area_id
if agent.committed_target_area_id != -1 and self.map_manager is not None:
    if agent.committed_target_area_id in self.map_manager.areas:
        committed_area = self.map_manager.areas[agent.committed_target_area_id]
        if agent.committed_target_area_id == agent.exit_node_id and agent.exit_pos is not None:
            target = agent.exit_pos
        else:
            target = np.array(committed_area.center)
```

**逻辑说明：**
- 实际移动目标基于 `committed_target_area_id`，而不是 `next_target_area_id`
- 这确保了行人在到达当前承诺的目标之前，不会因为路径规划的变化而改变移动方向

#### 2.3 到达目标后的更新

在 `update_state()` 中，检查是否到达目标区域：

```python
# 检查是否到达已承诺的目标区域
if self._point_in_area(agent.pos, committed_area):
    # 到达目标区域，更新committed_target_area_id为下一个目标
    # 使用next_target_area_id作为新的承诺目标（如果已设置）
    if agent.next_target_area_id != -1 and agent.next_target_area_id != agent.committed_target_area_id:
        # 更新承诺的目标ID
        agent.committed_target_area_id = agent.next_target_area_id
        # 更新目标点和路径索引
```

**逻辑说明：**
- 只有当行人真正到达（进入）已承诺的目标区域时，才更新 `committed_target_area_id`
- 更新时使用 `next_target_area_id`（路径规划的最新建议）作为新的承诺目标

### 3. 初始化处理

在以下情况下，如果 `committed_target_area_id` 未设置（为-1），则立即设置：

1. **路径规划后**：当确定下一个目标区域时
2. **路径重新规划时**：如果当前承诺的目标不在新路径中，重置为-1，等待重新设置
3. **路径规划失败时**：直接设置为出口ID

### 4. 从众行为优化

在计算从众行为得分时，使用 `committed_target_area_id` 而不是 `next_target_area_id`：

```python
# 使用committed_target_area_id来判断从众行为（更准确，反映实际移动目标）
neighbor_target_id = neighbor.committed_target_area_id if neighbor.committed_target_area_id != -1 else neighbor.next_target_area_id
```

**逻辑说明：**
- 从众行为应该基于邻居的实际移动目标（committed），而不是规划建议（next）
- 这样更准确地反映群体的实际运动方向

## 改进效果

### 1. 稳定性提升

- **之前**：路径规划每次变化都会立即改变移动目标，导致轨迹频繁变化
- **现在**：只有到达当前目标后才会更新目标，移动更加稳定

### 2. 行为更真实

- **之前**：行人可能在移动过程中频繁改变方向
- **现在**：行人会坚持到达当前目标，然后再考虑下一个目标，更符合真实行为

### 3. 路径规划与执行分离

- **之前**：路径规划直接控制移动
- **现在**：路径规划提供建议（`next_target_area_id`），实际移动基于承诺（`committed_target_area_id`）

## 关键代码位置

1. **字段定义**：`entities.py:121` - `committed_target_area_id`
2. **路径选择逻辑**：`managers.py:1029-1059` - `update_path()` 中的路径选择
3. **目标点确定**：`managers.py:1201-1211` - `update_state()` 中的目标点计算
4. **到达检测**：`managers.py:1255-1305` - `update_state()` 中的到达检测和更新
5. **从众行为**：`managers.py:857-870` - `choose_path()` 中的从众得分计算

## 注意事项

1. **初始化**：确保在路径规划后，如果 `committed_target_area_id` 为-1，要立即设置
2. **路径重新规划**：当路径重新规划时，如果当前承诺的目标不在新路径中，需要重置
3. **出口处理**：到达出口区域时，还需要检查是否到达 `exit_pos` 才完成疏散

## 总结

通过引入 `committed_target_area_id` 字段，实现了路径规划建议与实际移动目标的分离，使行人的移动行为更加稳定和真实。行人会坚持到达当前承诺的目标，不会因为路径规划的频繁变化而频繁改变方向。

